#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Id;


/********************   Forward Declarations    ********************/

class Program;
class Def;
class Com;
class Stm;
class Exp;
class PDefinitions;
class DFunction;
class DOperator;
class DHelp;
class DExpression;
class CComment;
class CEmpty;
class SExpression;
class SInit;
class SIfElse;
class EDouble;
class EInteger;
class EId;
class ECall;
class EUMinus;
class ETimes;
class EDiv;
class EPlus;
class EMinus;
class ELt;
class EGt;
class ELtEq;
class EGtEq;
class EEq;
class ENEq;
class EPercentage;
class EOperator;
class ListDef;
class ListStm;
class ListExp;
class ListId;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitDef(Def *p) = 0;
  virtual void visitCom(Com *p) = 0;
  virtual void visitStm(Stm *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitPDefinitions(PDefinitions *p) = 0;
  virtual void visitDFunction(DFunction *p) = 0;
  virtual void visitDOperator(DOperator *p) = 0;
  virtual void visitDHelp(DHelp *p) = 0;
  virtual void visitDExpression(DExpression *p) = 0;
  virtual void visitCComment(CComment *p) = 0;
  virtual void visitCEmpty(CEmpty *p) = 0;
  virtual void visitSExpression(SExpression *p) = 0;
  virtual void visitSInit(SInit *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitEDouble(EDouble *p) = 0;
  virtual void visitEInteger(EInteger *p) = 0;
  virtual void visitEId(EId *p) = 0;
  virtual void visitECall(ECall *p) = 0;
  virtual void visitEUMinus(EUMinus *p) = 0;
  virtual void visitETimes(ETimes *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEPlus(EPlus *p) = 0;
  virtual void visitEMinus(EMinus *p) = 0;
  virtual void visitELt(ELt *p) = 0;
  virtual void visitEGt(EGt *p) = 0;
  virtual void visitELtEq(ELtEq *p) = 0;
  virtual void visitEGtEq(EGtEq *p) = 0;
  virtual void visitEEq(EEq *p) = 0;
  virtual void visitENEq(ENEq *p) = 0;
  virtual void visitEPercentage(EPercentage *p) = 0;
  virtual void visitEOperator(EOperator *p) = 0;
  virtual void visitListDef(ListDef *p) = 0;
  virtual void visitListStm(ListStm *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListId(ListId *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitId(Id x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Def : public Visitable
{
public:
  virtual Def *clone() const = 0;

};

class Com : public Visitable
{
public:
  virtual Com *clone() const = 0;

};

class Stm : public Visitable
{
public:
  virtual Stm *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};



class PDefinitions : public Program
{
public:
  ListDef *listdef_;

  PDefinitions(const PDefinitions &);
  PDefinitions &operator=(const PDefinitions &);
  PDefinitions(ListDef *p1);
  ~PDefinitions();
  virtual void accept(Visitor *v);
  virtual PDefinitions *clone() const;
  void swap(PDefinitions &);
};

class DFunction : public Def
{
public:
  Id id_;
  ListId *listid_;
  Com *com_;
  ListStm *liststm_;
  Exp *exp_;

  DFunction(const DFunction &);
  DFunction &operator=(const DFunction &);
  DFunction(Id p1, ListId *p2, Com *p3, ListStm *p4, Exp *p5);
  ~DFunction();
  virtual void accept(Visitor *v);
  virtual DFunction *clone() const;
  void swap(DFunction &);
};

class DOperator : public Def
{
public:
  Id id_1;
  Id id_2;
  Id id_3;
  Com *com_;
  ListStm *liststm_;
  Exp *exp_;

  DOperator(const DOperator &);
  DOperator &operator=(const DOperator &);
  DOperator(Id p1, Id p2, Id p3, Com *p4, ListStm *p5, Exp *p6);
  ~DOperator();
  virtual void accept(Visitor *v);
  virtual DOperator *clone() const;
  void swap(DOperator &);
};

class DHelp : public Def
{
public:
  String string_;

  DHelp(const DHelp &);
  DHelp &operator=(const DHelp &);
  DHelp(String p1);
  ~DHelp();
  virtual void accept(Visitor *v);
  virtual DHelp *clone() const;
  void swap(DHelp &);
};

class DExpression : public Def
{
public:
  Exp *exp_;

  DExpression(const DExpression &);
  DExpression &operator=(const DExpression &);
  DExpression(Exp *p1);
  ~DExpression();
  virtual void accept(Visitor *v);
  virtual DExpression *clone() const;
  void swap(DExpression &);
};

class CComment : public Com
{
public:
  String string_;

  CComment(const CComment &);
  CComment &operator=(const CComment &);
  CComment(String p1);
  ~CComment();
  virtual void accept(Visitor *v);
  virtual CComment *clone() const;
  void swap(CComment &);
};

class CEmpty : public Com
{
public:

  CEmpty(const CEmpty &);
  CEmpty &operator=(const CEmpty &);
  CEmpty();
  ~CEmpty();
  virtual void accept(Visitor *v);
  virtual CEmpty *clone() const;
  void swap(CEmpty &);
};

class SExpression : public Stm
{
public:
  Exp *exp_;

  SExpression(const SExpression &);
  SExpression &operator=(const SExpression &);
  SExpression(Exp *p1);
  ~SExpression();
  virtual void accept(Visitor *v);
  virtual SExpression *clone() const;
  void swap(SExpression &);
};

class SInit : public Stm
{
public:
  Id id_;
  Exp *exp_;

  SInit(const SInit &);
  SInit &operator=(const SInit &);
  SInit(Id p1, Exp *p2);
  ~SInit();
  virtual void accept(Visitor *v);
  virtual SInit *clone() const;
  void swap(SInit &);
};

class SIfElse : public Stm
{
public:
  Exp *exp_;
  Stm *stm_1;
  Stm *stm_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Exp *p1, Stm *p2, Stm *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual SIfElse *clone() const;
  void swap(SIfElse &);
};

class EDouble : public Exp
{
public:
  Double double_;

  EDouble(const EDouble &);
  EDouble &operator=(const EDouble &);
  EDouble(Double p1);
  ~EDouble();
  virtual void accept(Visitor *v);
  virtual EDouble *clone() const;
  void swap(EDouble &);
};

class EInteger : public Exp
{
public:
  Integer integer_;

  EInteger(const EInteger &);
  EInteger &operator=(const EInteger &);
  EInteger(Integer p1);
  ~EInteger();
  virtual void accept(Visitor *v);
  virtual EInteger *clone() const;
  void swap(EInteger &);
};

class EId : public Exp
{
public:
  Id id_;

  EId(const EId &);
  EId &operator=(const EId &);
  EId(Id p1);
  ~EId();
  virtual void accept(Visitor *v);
  virtual EId *clone() const;
  void swap(EId &);
};

class ECall : public Exp
{
public:
  Id id_;
  ListExp *listexp_;

  ECall(const ECall &);
  ECall &operator=(const ECall &);
  ECall(Id p1, ListExp *p2);
  ~ECall();
  virtual void accept(Visitor *v);
  virtual ECall *clone() const;
  void swap(ECall &);
};

class EUMinus : public Exp
{
public:
  Exp *exp_;

  EUMinus(const EUMinus &);
  EUMinus &operator=(const EUMinus &);
  EUMinus(Exp *p1);
  ~EUMinus();
  virtual void accept(Visitor *v);
  virtual EUMinus *clone() const;
  void swap(EUMinus &);
};

class ETimes : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ETimes(const ETimes &);
  ETimes &operator=(const ETimes &);
  ETimes(Exp *p1, Exp *p2);
  ~ETimes();
  virtual void accept(Visitor *v);
  virtual ETimes *clone() const;
  void swap(ETimes &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class EPlus : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EPlus(const EPlus &);
  EPlus &operator=(const EPlus &);
  EPlus(Exp *p1, Exp *p2);
  ~EPlus();
  virtual void accept(Visitor *v);
  virtual EPlus *clone() const;
  void swap(EPlus &);
};

class EMinus : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMinus(const EMinus &);
  EMinus &operator=(const EMinus &);
  EMinus(Exp *p1, Exp *p2);
  ~EMinus();
  virtual void accept(Visitor *v);
  virtual EMinus *clone() const;
  void swap(EMinus &);
};

class ELt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELt(const ELt &);
  ELt &operator=(const ELt &);
  ELt(Exp *p1, Exp *p2);
  ~ELt();
  virtual void accept(Visitor *v);
  virtual ELt *clone() const;
  void swap(ELt &);
};

class EGt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGt(const EGt &);
  EGt &operator=(const EGt &);
  EGt(Exp *p1, Exp *p2);
  ~EGt();
  virtual void accept(Visitor *v);
  virtual EGt *clone() const;
  void swap(EGt &);
};

class ELtEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELtEq(const ELtEq &);
  ELtEq &operator=(const ELtEq &);
  ELtEq(Exp *p1, Exp *p2);
  ~ELtEq();
  virtual void accept(Visitor *v);
  virtual ELtEq *clone() const;
  void swap(ELtEq &);
};

class EGtEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGtEq(const EGtEq &);
  EGtEq &operator=(const EGtEq &);
  EGtEq(Exp *p1, Exp *p2);
  ~EGtEq();
  virtual void accept(Visitor *v);
  virtual EGtEq *clone() const;
  void swap(EGtEq &);
};

class EEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq(Exp *p1, Exp *p2);
  ~EEq();
  virtual void accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class ENEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENEq(const ENEq &);
  ENEq &operator=(const ENEq &);
  ENEq(Exp *p1, Exp *p2);
  ~ENEq();
  virtual void accept(Visitor *v);
  virtual ENEq *clone() const;
  void swap(ENEq &);
};

class EPercentage : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EPercentage(const EPercentage &);
  EPercentage &operator=(const EPercentage &);
  EPercentage(Exp *p1, Exp *p2);
  ~EPercentage();
  virtual void accept(Visitor *v);
  virtual EPercentage *clone() const;
  void swap(EPercentage &);
};

class EOperator : public Exp
{
public:
  Exp *exp_1;
  Id id_;
  Exp *exp_2;

  EOperator(const EOperator &);
  EOperator &operator=(const EOperator &);
  EOperator(Exp *p1, Id p2, Exp *p3);
  ~EOperator();
  virtual void accept(Visitor *v);
  virtual EOperator *clone() const;
  void swap(EOperator &);
};



class ListDef : public Visitable, public std::vector<Def*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDef *clone() const;
};

class ListStm : public Visitable, public std::vector<Stm*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStm *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListId : public Visitable, public std::vector<Id>
{
public:
  virtual void accept(Visitor *v);
  virtual ListId *clone() const;
};



#endif
