//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   PDefinitions    ********************/
PDefinitions::PDefinitions(ListDef *p1)
{
  listdef_ = p1;

}

PDefinitions::PDefinitions(const PDefinitions & other)
{
  listdef_ = other.listdef_->clone();

}

PDefinitions &PDefinitions::operator=(const PDefinitions & other)
{
  PDefinitions tmp(other);
  swap(tmp);
  return *this;
}

void PDefinitions::swap(PDefinitions & other)
{
  std::swap(listdef_, other.listdef_);

}

PDefinitions::~PDefinitions()
{
  delete(listdef_);

}

void PDefinitions::accept(Visitor *v)
{
  v->visitPDefinitions(this);
}

PDefinitions *PDefinitions::clone() const
{
  return new PDefinitions(*this);
}



/********************   DFunction    ********************/
DFunction::DFunction(Id p1, ListId *p2, Com *p3, ListStm *p4, Exp *p5)
{
  id_ = p1;
  listid_ = p2;
  com_ = p3;
  liststm_ = p4;
  exp_ = p5;

}

DFunction::DFunction(const DFunction & other)
{
  id_ = other.id_;
  listid_ = other.listid_->clone();
  com_ = other.com_->clone();
  liststm_ = other.liststm_->clone();
  exp_ = other.exp_->clone();

}

DFunction &DFunction::operator=(const DFunction & other)
{
  DFunction tmp(other);
  swap(tmp);
  return *this;
}

void DFunction::swap(DFunction & other)
{
  std::swap(id_, other.id_);
  std::swap(listid_, other.listid_);
  std::swap(com_, other.com_);
  std::swap(liststm_, other.liststm_);
  std::swap(exp_, other.exp_);

}

DFunction::~DFunction()
{
  delete(listid_);
  delete(com_);
  delete(liststm_);
  delete(exp_);

}

void DFunction::accept(Visitor *v)
{
  v->visitDFunction(this);
}

DFunction *DFunction::clone() const
{
  return new DFunction(*this);
}



/********************   DOperator    ********************/
DOperator::DOperator(Id p1, Id p2, Id p3, Com *p4, ListStm *p5, Exp *p6)
{
  id_1 = p1;
  id_2 = p2;
  id_3 = p3;
  com_ = p4;
  liststm_ = p5;
  exp_ = p6;

}

DOperator::DOperator(const DOperator & other)
{
  id_1 = other.id_1;
  id_2 = other.id_2;
  id_3 = other.id_3;
  com_ = other.com_->clone();
  liststm_ = other.liststm_->clone();
  exp_ = other.exp_->clone();

}

DOperator &DOperator::operator=(const DOperator & other)
{
  DOperator tmp(other);
  swap(tmp);
  return *this;
}

void DOperator::swap(DOperator & other)
{
  std::swap(id_1, other.id_1);
  std::swap(id_2, other.id_2);
  std::swap(id_3, other.id_3);
  std::swap(com_, other.com_);
  std::swap(liststm_, other.liststm_);
  std::swap(exp_, other.exp_);

}

DOperator::~DOperator()
{
  delete(com_);
  delete(liststm_);
  delete(exp_);

}

void DOperator::accept(Visitor *v)
{
  v->visitDOperator(this);
}

DOperator *DOperator::clone() const
{
  return new DOperator(*this);
}



/********************   DHelp    ********************/
DHelp::DHelp(String p1)
{
  string_ = p1;

}

DHelp::DHelp(const DHelp & other)
{
  string_ = other.string_;

}

DHelp &DHelp::operator=(const DHelp & other)
{
  DHelp tmp(other);
  swap(tmp);
  return *this;
}

void DHelp::swap(DHelp & other)
{
  std::swap(string_, other.string_);

}

DHelp::~DHelp()
{

}

void DHelp::accept(Visitor *v)
{
  v->visitDHelp(this);
}

DHelp *DHelp::clone() const
{
  return new DHelp(*this);
}



/********************   DExpression    ********************/
DExpression::DExpression(Exp *p1)
{
  exp_ = p1;

}

DExpression::DExpression(const DExpression & other)
{
  exp_ = other.exp_->clone();

}

DExpression &DExpression::operator=(const DExpression & other)
{
  DExpression tmp(other);
  swap(tmp);
  return *this;
}

void DExpression::swap(DExpression & other)
{
  std::swap(exp_, other.exp_);

}

DExpression::~DExpression()
{
  delete(exp_);

}

void DExpression::accept(Visitor *v)
{
  v->visitDExpression(this);
}

DExpression *DExpression::clone() const
{
  return new DExpression(*this);
}



/********************   CComment    ********************/
CComment::CComment(String p1)
{
  string_ = p1;

}

CComment::CComment(const CComment & other)
{
  string_ = other.string_;

}

CComment &CComment::operator=(const CComment & other)
{
  CComment tmp(other);
  swap(tmp);
  return *this;
}

void CComment::swap(CComment & other)
{
  std::swap(string_, other.string_);

}

CComment::~CComment()
{

}

void CComment::accept(Visitor *v)
{
  v->visitCComment(this);
}

CComment *CComment::clone() const
{
  return new CComment(*this);
}



/********************   CEmpty    ********************/
CEmpty::CEmpty()
{

}

CEmpty::CEmpty(const CEmpty & other)
{

}

CEmpty &CEmpty::operator=(const CEmpty & other)
{
  CEmpty tmp(other);
  swap(tmp);
  return *this;
}

void CEmpty::swap(CEmpty & other)
{

}

CEmpty::~CEmpty()
{

}

void CEmpty::accept(Visitor *v)
{
  v->visitCEmpty(this);
}

CEmpty *CEmpty::clone() const
{
  return new CEmpty(*this);
}



/********************   SExpression    ********************/
SExpression::SExpression(Exp *p1)
{
  exp_ = p1;

}

SExpression::SExpression(const SExpression & other)
{
  exp_ = other.exp_->clone();

}

SExpression &SExpression::operator=(const SExpression & other)
{
  SExpression tmp(other);
  swap(tmp);
  return *this;
}

void SExpression::swap(SExpression & other)
{
  std::swap(exp_, other.exp_);

}

SExpression::~SExpression()
{
  delete(exp_);

}

void SExpression::accept(Visitor *v)
{
  v->visitSExpression(this);
}

SExpression *SExpression::clone() const
{
  return new SExpression(*this);
}



/********************   SInit    ********************/
SInit::SInit(Id p1, Exp *p2)
{
  id_ = p1;
  exp_ = p2;

}

SInit::SInit(const SInit & other)
{
  id_ = other.id_;
  exp_ = other.exp_->clone();

}

SInit &SInit::operator=(const SInit & other)
{
  SInit tmp(other);
  swap(tmp);
  return *this;
}

void SInit::swap(SInit & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_, other.exp_);

}

SInit::~SInit()
{
  delete(exp_);

}

void SInit::accept(Visitor *v)
{
  v->visitSInit(this);
}

SInit *SInit::clone() const
{
  return new SInit(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Exp *p1, Stm *p2, Stm *p3)
{
  exp_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  exp_ = other.exp_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

SIfElse::~SIfElse()
{
  delete(exp_);
  delete(stm_1);
  delete(stm_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   EInteger    ********************/
EInteger::EInteger(Integer p1)
{
  integer_ = p1;

}

EInteger::EInteger(const EInteger & other)
{
  integer_ = other.integer_;

}

EInteger &EInteger::operator=(const EInteger & other)
{
  EInteger tmp(other);
  swap(tmp);
  return *this;
}

void EInteger::swap(EInteger & other)
{
  std::swap(integer_, other.integer_);

}

EInteger::~EInteger()
{

}

void EInteger::accept(Visitor *v)
{
  v->visitEInteger(this);
}

EInteger *EInteger::clone() const
{
  return new EInteger(*this);
}



/********************   EId    ********************/
EId::EId(Id p1)
{
  id_ = p1;

}

EId::EId(const EId & other)
{
  id_ = other.id_;

}

EId &EId::operator=(const EId & other)
{
  EId tmp(other);
  swap(tmp);
  return *this;
}

void EId::swap(EId & other)
{
  std::swap(id_, other.id_);

}

EId::~EId()
{

}

void EId::accept(Visitor *v)
{
  v->visitEId(this);
}

EId *EId::clone() const
{
  return new EId(*this);
}



/********************   ECall    ********************/
ECall::ECall(Id p1, ListExp *p2)
{
  id_ = p1;
  listexp_ = p2;

}

ECall::ECall(const ECall & other)
{
  id_ = other.id_;
  listexp_ = other.listexp_->clone();

}

ECall &ECall::operator=(const ECall & other)
{
  ECall tmp(other);
  swap(tmp);
  return *this;
}

void ECall::swap(ECall & other)
{
  std::swap(id_, other.id_);
  std::swap(listexp_, other.listexp_);

}

ECall::~ECall()
{
  delete(listexp_);

}

void ECall::accept(Visitor *v)
{
  v->visitECall(this);
}

ECall *ECall::clone() const
{
  return new ECall(*this);
}



/********************   EUMinus    ********************/
EUMinus::EUMinus(Exp *p1)
{
  exp_ = p1;

}

EUMinus::EUMinus(const EUMinus & other)
{
  exp_ = other.exp_->clone();

}

EUMinus &EUMinus::operator=(const EUMinus & other)
{
  EUMinus tmp(other);
  swap(tmp);
  return *this;
}

void EUMinus::swap(EUMinus & other)
{
  std::swap(exp_, other.exp_);

}

EUMinus::~EUMinus()
{
  delete(exp_);

}

void EUMinus::accept(Visitor *v)
{
  v->visitEUMinus(this);
}

EUMinus *EUMinus::clone() const
{
  return new EUMinus(*this);
}



/********************   ETimes    ********************/
ETimes::ETimes(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ETimes::ETimes(const ETimes & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ETimes &ETimes::operator=(const ETimes & other)
{
  ETimes tmp(other);
  swap(tmp);
  return *this;
}

void ETimes::swap(ETimes & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ETimes::~ETimes()
{
  delete(exp_1);
  delete(exp_2);

}

void ETimes::accept(Visitor *v)
{
  v->visitETimes(this);
}

ETimes *ETimes::clone() const
{
  return new ETimes(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EPlus    ********************/
EPlus::EPlus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EPlus::EPlus(const EPlus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EPlus &EPlus::operator=(const EPlus & other)
{
  EPlus tmp(other);
  swap(tmp);
  return *this;
}

void EPlus::swap(EPlus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EPlus::~EPlus()
{
  delete(exp_1);
  delete(exp_2);

}

void EPlus::accept(Visitor *v)
{
  v->visitEPlus(this);
}

EPlus *EPlus::clone() const
{
  return new EPlus(*this);
}



/********************   EMinus    ********************/
EMinus::EMinus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMinus::EMinus(const EMinus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMinus &EMinus::operator=(const EMinus & other)
{
  EMinus tmp(other);
  swap(tmp);
  return *this;
}

void EMinus::swap(EMinus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMinus::~EMinus()
{
  delete(exp_1);
  delete(exp_2);

}

void EMinus::accept(Visitor *v)
{
  v->visitEMinus(this);
}

EMinus *EMinus::clone() const
{
  return new EMinus(*this);
}



/********************   ELt    ********************/
ELt::ELt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELt::ELt(const ELt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELt::~ELt()
{
  delete(exp_1);
  delete(exp_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGt::EGt(const EGt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGt::~EGt()
{
  delete(exp_1);
  delete(exp_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   ELtEq    ********************/
ELtEq::ELtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELtEq::ELtEq(const ELtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELtEq &ELtEq::operator=(const ELtEq & other)
{
  ELtEq tmp(other);
  swap(tmp);
  return *this;
}

void ELtEq::swap(ELtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELtEq::~ELtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ELtEq::accept(Visitor *v)
{
  v->visitELtEq(this);
}

ELtEq *ELtEq::clone() const
{
  return new ELtEq(*this);
}



/********************   EGtEq    ********************/
EGtEq::EGtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGtEq::EGtEq(const EGtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGtEq &EGtEq::operator=(const EGtEq & other)
{
  EGtEq tmp(other);
  swap(tmp);
  return *this;
}

void EGtEq::swap(EGtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGtEq::~EGtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EGtEq::accept(Visitor *v)
{
  v->visitEGtEq(this);
}

EGtEq *EGtEq::clone() const
{
  return new EGtEq(*this);
}



/********************   EEq    ********************/
EEq::EEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEq::EEq(const EEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEq::~EEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   EPercentage    ********************/
EPercentage::EPercentage(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EPercentage::EPercentage(const EPercentage & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EPercentage &EPercentage::operator=(const EPercentage & other)
{
  EPercentage tmp(other);
  swap(tmp);
  return *this;
}

void EPercentage::swap(EPercentage & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EPercentage::~EPercentage()
{
  delete(exp_1);
  delete(exp_2);

}

void EPercentage::accept(Visitor *v)
{
  v->visitEPercentage(this);
}

EPercentage *EPercentage::clone() const
{
  return new EPercentage(*this);
}



/********************   EOperator    ********************/
EOperator::EOperator(Exp *p1, Id p2, Exp *p3)
{
  exp_1 = p1;
  id_ = p2;
  exp_2 = p3;

}

EOperator::EOperator(const EOperator & other)
{
  exp_1 = other.exp_1->clone();
  id_ = other.id_;
  exp_2 = other.exp_2->clone();

}

EOperator &EOperator::operator=(const EOperator & other)
{
  EOperator tmp(other);
  swap(tmp);
  return *this;
}

void EOperator::swap(EOperator & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(id_, other.id_);
  std::swap(exp_2, other.exp_2);

}

EOperator::~EOperator()
{
  delete(exp_1);
  delete(exp_2);

}

void EOperator::accept(Visitor *v)
{
  v->visitEOperator(this);
}

EOperator *EOperator::clone() const
{
  return new EOperator(*this);
}




/********************   ListDef    ********************/

void ListDef::accept(Visitor *v)
{
  v->visitListDef(this);
}


ListDef *ListDef::clone() const
{
  return new ListDef(*this);
}


/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}


ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListId    ********************/

void ListId::accept(Visitor *v)
{
  v->visitListId(this);
}


ListId *ListId::clone() const
{
  return new ListId(*this);
}




